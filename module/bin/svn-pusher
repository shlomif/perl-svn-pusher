#!/usr/bin/perl -w
use strict;
use lib qw{.} ;
use SVN::Core '0.32';
use SVN::Pusher::CmdLine;
use Getopt::Long ;


# Autoflush
$| = 1;

=head1 NAME

svn-pusher - command line interface for propagating Subversion changesets. 

=head1 SYNOPSIS

    % svn-pusher push http://hosta/path http://hostb/path

=head1 DESCRIPTION

F<svn-pusher> propagats changesets from one Subversion repository
to another.

=head1 COMMANDS

=over

=item push [options] B<srcurl> B<desturl> 

Invoke the push of B<srcurl> to B<desturl>

Possible options:

=over

=item -c --create

Initialzie B<desturl> for pushing if not already done

=item -m --message=<text>

Use <text> for B<every> commit that is done during push

=item -r --revision=<from>:<to>

Push only changes between (including) the two given revision.
Revision can also be C<HEAD> which means the newest revision in
the repository.

=back

Example:

  svn-pusher push -r 4:6 -m 'New Release' https://svn.example.com/repos https://svn2.example.com/release

This will push the HEAD revision of the first URL to the second URL. The
direcory of the second URL will be created if it isn't there. If, since the
last push, multiple revision had been commited to the source, they will be
commited as one revision to the destination. If you leave out the -r option
every revision in the source will be commited as one revision to the
destination.

=back

=back 

=cut

# --------------------------------------------------------------------------

sub do_help {
    require Pod::Text;
    my $parser = Pod::Text->new (sentence => 0, width => 78);
    $parser->parse_from_file ($0, '-' );
}

# --------------------------------------------------------------------------

sub opt_push { return ('create|c', 'message|m:s', 'revision|r:s') }


sub do_push 
{
    die "$0 push [--create] [--message=<text>] [--revision=<from>:<to>] <source> <target>\n" unless $#_ >= 2;
    my ($options, $source, $target) = @_;

    my %revs ;
    if ($options -> {revision})
	{
        my ($start, $end) = split (/:/, $options -> {revision}, 2) ;	
	%revs = (startrev => $start, endrev => $end) ;
	}

    my $m = SVN::Pusher::CmdLine->new( target  => $target,
                       	    source  => $source,
			    %revs,
                       	    logmsg  => $options -> {message});

    if ($m->init ($options -> {create}) > 0)
    	{
    	$m->run;
    	}
}


# --------------------------------------------------------------------------

my $cmd = shift || 'help';

my $cmdsub = "do_$cmd" ;
my $cmdopt = "opt_$cmd" ;

die "Command not recognized. Try $0 help\n" unless main->can($cmdsub);

my %options ;
if (my $cmdopt_ref = main -> can ($cmdopt))
{
    eval { Getopt::Long::Configure ('bundling') } ;
    $@ = "" ;
    my $ret = GetOptions (\%options, $cmdopt_ref->()) ;
}

main->can($cmdsub)->(\%options, @ARGV);


=head1 AUTHORS

Shlomi Fish E<lt>shlomif@iglu.org.ilE<gt>
Gerald Richter E<lt>richter@dev.ecos.deE<gt>

=head1 CREDITS

A lot of ideas and code were taken from SVN::Mirror which was written by
Chia-liang Kao E<lt>clkao@clkao.orgE<gt>

=head1 COPYRIGHT

Copyright 2004 by Gerald Richter E<lt>richter@dev.ecos.deE<gt>

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

See L<http://www.perl.com/perl/misc/Artistic.html>

=cut

1;
